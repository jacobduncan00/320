# Lab 3 

## Questions:

*bold* (a) Summarize your approach to the problem, and how your code addresses the abstractions needed.

*bold* (b) What is the theoretical time complexity of your sorting algorithm (best and worst case), in terms of the array size?

*bold* (c) Test your sorting algorithm on different size and types of arrays, as you did with labs 1 and 2. Be sure to vary the parameters enough to use the observations to answer the next questions!

*bold* (d)  How does the absolute timing scale with the number of elements in the array? The size of the elements? Use the data collected to rectify this with the theoretical time complexity, e.g. what non-asymptotic function of n mostly closely matches the timings that you observe as n grows?

*bold* (e) Aggregate your data into a graph of the complexity for the various array sizes, for example with a spreadsheet program like LibreOffice Calc or Microsoft Word.

*bold* (f) How does the sort perform in different cases? What is the best and worst case, according to your own test results?

*bold* (g) How could the code be improved in terms of usability, efficiency, and robustness?